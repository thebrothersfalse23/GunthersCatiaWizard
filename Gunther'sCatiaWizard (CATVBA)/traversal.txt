
' Module-level variables for global state management
' These variables are declared as Public in a standard module (e.g., Globals.bas)
' to avoid passing them as arguments between functions/subs.

Public rootDoc As Document           ' CATIA.activeDocument
Public rootProd As Product           ' CATIA.activeDocument.Product
Public rootSel As Selection          ' CATIA.activeDocument.Selection
Public currentProd As Product        ' The currently processed product object.
Public selectedProds As Collection   ' Collection of product objects selected by the user or process.
Public templateProd As Product       ' The product object used as a template for creating new products.
Public uniqueProdRefs As Collection  ' Collection of unique product reference identifiers.
Public uniqueProds As Collection     ' Collection of unique product objects (no duplicates).
Public uniquePartRefs As Collection  ' Collection of unique part reference identifiers.
Public uniqueParts As Collection     ' Collection of unique part objects (no duplicates).
Public allProdRefs As Collection     ' Collection of all product reference identifiers in the structure.
Public allProds As Collection        ' Collection of all product objects in the structure.
Public allUniques As Collection      ' Collection of all unique objects (products and/or parts).
Public allInstances As Collection    ' Collection of all product or part instances in the assembly.
Public partDocs As Collection        ' Collection of document objects corresponding to parts.
Public prodDocs As Collection        ' Collection of document objects corresponding to products.
Public allPartNumbers As Collection  ' Collection of all part numbers in the structure.
Public allNames As Collection        ' Collection of all product/part names in the structure.
Public allDescriptions As Collection ' Collection of all descriptions in the structure.
Public errorLog As Collection        ' Collection of error messages or logs for debugging.
Public processedNodes As Collection  ' Collection of already processed nodes/products to avoid cycles.
Public parentProds As Collection     ' Collection of parent product objects for hierarchy tracking.
Public childProds As Collection      ' Collection of child product objects for hierarchy tracking.
Public userInputs As Collection      ' Collection of user input values for session tracking.
Public tempCache As Collection       ' Temporary cache for intermediate results during processing.


Enum traversalModes
    tmCollectUniques = 0             ' Function: Returns a collection of unique products found during BFS
    tmCollectAllInstances = 1        ' Function: Returns all product instances (including duplicates) found during BFS
    tmCollectParts = 2               ' Function: Returns only part objects (excluding assemblies)
    tmCollectProducts = 3            ' Function: Returns only product (assembly) objects (excluding parts)
    tmDuplicateProduct = 4           ' Function: Duplicates a product and its structure
    tmAssignProductData = 5          ' Function: Assigns property data to products during traversal
    tmCopyTemplate = 6               ' Function: Copies a product template
    tmCollectLeaves = 7              ' Function: Returns only leaf products (end-nodes)
    tmCollectAssemblies = 8          ' Function: Returns only assemblies (products with children)
    tmCollectByProperty = 9          ' Function: Returns products matching a specific property value
    tmCollectByName = 10             ' Function: Returns products with a specific name
    tmCollectByPartNumber = 11       ' Function: Returns products with a specific part number
    tmCollectByCustomFilter = 12     ' Function: Returns products matching a custom filter function
    tmCountProducts = 13             ' Function: Counts the number of products during traversal
    tmCountParts = 14                ' Function: Counts the number of parts during traversal
    tmLogTraversal = 15              ' Sub: Logs traversal steps for debugging or reporting
    tmValidateStructure = 16         ' Function: Validates product structure for errors or inconsistencies
    tmCollectParents = 17            ' Function: Returns parent products for each node
    tmCollectChildren = 18           ' Function: Returns child products for each node
    tmCollectPaths = 19              ' Function: Returns paths from root to each product/part
    tmSaveAll = 20                   ' Sub: Saves all existing products/parts
    tmSaveAsAll = 21                 ' Sub: Saves all existing products/parts with a new name
    tmSendTo = 22                    ' Sub: copies catia's native 'Send To' functionality 
End Enum



Public Sub traverseProduct(ByVal mode As traversalModes, ByRef traversalParams As Collection)
'--- Mode-specific state
Dim mode As traversalModes
Dim root As Product
Dim q As Collection
Dim current As Product
Dim kids As Products
Dim ref As Product
Dim enqueueEarly As Boolean
Dim enqueueLate As Boolean
Dim i As Long

Select Case mode

    ' --- Traversal parameter parsing system ---
    ' Each mode expects specific parameters in traversalParams (a Collection with key/value pairs).
    ' This block extracts and assigns those parameters to local variables for use in the traversal logic.
    ' If a required parameter is missing, an error is raised for easier debugging.
    ' All parameter extraction is wrapped in error handling for robustness.

    Dim paramKey As String
    On Error GoTo ParamParseError
    Select Case mode
        Case tmCollectUniques
            ' Expects: "uniques" (Collection)
            Dim localUniques As Collection
            Set localUniques = traversalParams("uniques")

        Case tmCollectAllInstances
            ' Expects: "allInstances" (Collection)
            Dim localAllInstances As Collection
            Set localAllInstances = traversalParams("allInstances")

        Case tmCollectParts
            ' Expects: "parts" (Collection)
            Dim localParts As Collection
            Set localParts = traversalParams("parts")

        Case tmCollectProducts
            ' Expects: "products" (Collection)
            Dim localProducts As Collection
            Set localProducts = traversalParams("products")

        Case tmDuplicateProduct
            ' Expects: "duplicatedProd" (Product)
            Dim localDuplicatedProd As Product
            Set localDuplicatedProd = traversalParams("duplicatedProd")

        Case tmAssignProductData
            ' Expects: "assignType" (assignProductDataHelpers), "value" (Variant)
            Dim localAssignType As assignProductDataHelpers
            Dim localAssignValue As Variant
            localAssignType = traversalParams("assignType")
            localAssignValue = traversalParams("value")

        Case tmCopyTemplate
            ' Expects: "template" (Product)
            Dim localTemplate As Product
            Set localTemplate = traversalParams("template")

        Case tmCollectLeaves
            ' Expects: "leaves" (Collection)
            Dim localLeaves As Collection
            Set localLeaves = traversalParams("leaves")

        Case tmCollectAssemblies
            ' Expects: "assemblies" (Collection)
            Dim localAssemblies As Collection
            Set localAssemblies = traversalParams("assemblies")

        Case tmCollectByProperty
            ' Expects: "propName" (String), "propValue" (Variant), "matches" (Collection)
            Dim localPropName As String
            Dim localPropValue As Variant
            Dim localMatches As Collection
            localPropName = traversalParams("propName")
            localPropValue = traversalParams("propValue")
            Set localMatches = traversalParams("matches")

        Case tmCollectByName
            ' Expects: "nameToMatch" (String), "matches" (Collection)
            Dim localNameToMatch As String
            Dim localMatches As Collection
            localNameToMatch = traversalParams("nameToMatch")
            Set localMatches = traversalParams("matches")

        Case tmCollectByPartNumber
            ' Expects: "partNumber" (String), "matches" (Collection)
            Dim localPartNumberToMatch As String
            Dim localMatches As Collection
            localPartNumberToMatch = traversalParams("partNumber")
            Set localMatches = traversalParams("matches")

        Case tmCollectByCustomFilter
            ' Expects: "filterFunc" (String), "matches" (Collection)
            Dim localFilterFunc As String
            Dim localMatches As Collection
            localFilterFunc = traversalParams("filterFunc")
            Set localMatches = traversalParams("matches")

        Case tmCountProducts
            ' Expects: "count" (Long, ByRef)
            Dim localProdCount As Long
            localProdCount = traversalParams("count")

        Case tmCountParts
            ' Expects: "count" (Long, ByRef)
            Dim localPartCount As Long
            localPartCount = traversalParams("count")

        Case tmLogTraversal
            ' Expects: "logFilePath" (String)
            Dim localLogFilePath As String
            localLogFilePath = traversalParams("logFilePath")

        Case tmValidateStructure
            ' Expects: "isValid" (Boolean, ByRef), "errorList" (Collection)
            Dim localIsValid As Boolean
            Dim localErrorList As Collection
            localIsValid = traversalParams("isValid")
            Set localErrorList = traversalParams("errorList")

        Case tmCollectParents
            ' Expects: "parents" (Collection)
            Dim localParents As Collection
            Set localParents = traversalParams("parents")

        Case tmCollectChildren
            ' Expects: "children" (Collection)
            Dim localChildren As Collection
            Set localChildren = traversalParams("children")

        Case tmCollectPaths
            ' Expects: "paths" (Collection)
            Dim localPaths As Collection
            Set localPaths = traversalParams("paths")

        Case tmSaveAll
            ' No additional parameters required for saveAll

        Case tmSaveAsAll
            ' Expects: "newName" (String)
            Dim localNewName As String
            localNewName = traversalParams("newName")

        Case tmSendTo
            ' Expects: "destination" (String)
            Dim localDestination As String
            localDestination = traversalParams("destination")
    End Select
    On Error GoTo 0
    GoTo ParamParseDone

ParamParseError:
    ' If a required parameter is missing, raise a descriptive error
    MsgBox "[traverseProduct] Missing or invalid parameter for mode " & mode & ": " & Err.Description, vbCritical, "Parameter Parsing Error"
    Resume ParamParseDone

ParamParseDone:

'--- Start BFS  q.Add root
    Do While q.Count > 0
        Set current = q(1): q.Remove 1
        If Not current Is Nothing Then

            ' Decide enqueue policy once per node
            enqueueEarly = (mode = duplicateProduct)
            enqueueLate  = (Not enqueueEarly)

            If enqueueEarly Then
                On Error Resume Next
                Set kids = current.Products
                If Err.Number = 0 And Not kids Is Nothing Then
                    For i = 1 To kids.Count
                        q.Add kids.Item(i)
                    Next
                End If
                Err.Clear
                On Error GoTo 0
            End If

            ' Resolve reference safely (some instance nodes may not resolve)
            Set ref = Nothing
            On Error Resume Next
            Set ref = current.ReferenceProduct
            On Error GoTo 0

            If Not ref Is Nothing Then
                '--- Dispatch per traversal mode to isolated handlers
                Select Case mode
                    Case tmCollectUniques
                        ' Add unique reference/product to uniqueProds if not already present.
                        ' Use buildRefKey to generate a uniqueness key.
                        ' If not in uniqueProdRefs, add to uniqueProdRefs and uniqueProds.
                    Case tmCollectAllInstances
                        ' Add every encountered product instance (including duplicates) to allInstances collection.
                    Case tmCollectParts
                        ' If current node is a part (not an assembly), add to uniqueParts and uniquePartRefs if not already present.
                    Case tmCollectProducts
                        ' If current node is an assembly (not a part), add to uniqueProds and uniqueProdRefs if not already present.
                    Case tmDuplicateProduct
                        ' Duplicate the current product and its structure.
                        ' Create a new product, copy properties, and recursively duplicate children.
                    Case tmAssignProductData
                        ' Assign specified property (based on assignType and value) to the current product using assignProductProperty.
                    Case tmCopyTemplate
                        ' Copy relevant properties from the template product to the current product.
                    Case tmCollectLeaves
                        ' If current node has no children, add to leaves collection.
                    Case tmCollectAssemblies
                        ' If current node has children, add to assemblies collection.
                    Case tmCollectByProperty
                        ' If current product's specified property matches the given value, add to matches collection.
                    Case tmCollectByName
                        ' If current product's name matches the specified name, add to matches collection.
                    Case tmCollectByPartNumber
                        ' If current product's part number matches the specified value, add to matches collection.
                    Case tmCollectByCustomFilter
                        ' Call the custom filter function (by name) on current product.
                        ' If it returns True, add to matches collection.
                    Case tmCountProducts
                        ' If current node is an assembly, increment the products counter.
                    Case tmCountParts
                        ' If current node is a part, increment the parts counter.
                    Case tmLogTraversal
                        ' Log relevant information about the current node (e.g., name, type, path) to log file or debug window.
                    Case tmValidateStructure
                        ' Check for structural errors or inconsistencies in the current node.
                        ' If errors found, add to errorList and set isValid to False.
                    Case tmCollectParents
                        ' Record the parent of the current node in the parents collection.
                    Case tmCollectChildren
                        ' Record the children of the current node in the children collection.
                    Case tmCollectPaths
                        ' Record the path from root to the current node in the paths collection.
                    Case tmSaveAll
                        ' Save the current product/part document.
                    Case tmSaveAsAll
                        ' Save the current product/part document with a new name.
                    Case tmSendTo
                        ' CATIA's native "Send To" functionality is not accessible from VBA.
                        ' As an alternative, you can implement custom export/copy logic here,
                        ' such as saving the document to a specified destination using SaveAs,
                        ' or copying the file at the OS level if the document is saved.
                        ' Example (pseudo-code):
                        ' If Not destination = "" Then
                        '     current.Parent.SaveAs destination & "\" & current.Parent.Name
                        ' End If
                End Select

            ' Enqueue children late for all modes EXCEPT DeepCopy (avoids double-enqueue)
            If enqueueLate Then
                On Error Resume Next
                Set kids = current.Products
                If Err.Number = 0 And Not kids Is Nothing Then
                    For i = 1 To kids.Count
                        q.Add kids.Item(i)
                    Next
                End If
                Err.Clear
                On Error GoTo 0
            End If

        End If
    Loop
End Sub

' Determine reference document type from its owning Document name
Private Function getRefDocType(ByVal ref As Product) As String
    On Error Resume Next
    Dim nm As String: nm = ref.Parent.Name  ' Document.Name (e.g., *.CATPart / *.CATProduct)
    On Error GoTo 0
    If InStr(1, nm, ".CATPart", vbTextCompare) > 0 Then
        getRefDocType = "PartDocument"
    ElseIf InStr(1, nm, ".CATProduct", vbTextCompare) > 0 Then
        getRefDocType = "ProductDocument"
    Else
        getRefDocType = ""
    End If
End Function

' Build a stable uniqueness key for a reference
Private Function buildRefKey(ByVal ref As Product, ByVal docType As String) As String
    ' Prefer PartNumber when available; Name can vary with instances.
    Dim pn As String, nm As String
    On Error Resume Next
    pn = ref.PartNumber
    nm = ref.Name
    On Error GoTo 0
    If pn = "" Then pn = nm
    buildRefKey = docType & "|" & UCase$(Trim$(pn))
End Function


' 0. Collect unique products
Sub collectUniques(Optional ByRef targetProd As Product = Nothing, Optional ByRef uniques As Collection = Nothing)
    If targetProd Is Nothing Then Set targetProd = rootProd
    If uniques Is Nothing Then Set uniques = uniqueProds
    Dim traverseParams As New Collection
    traverseParams.Add targetProd, "targetProd"
    traverseParams.Add uniques, "uniques"
    Call traverseProduct(tmCollectUniques, traverseParams)

End Sub


' 1. Collect all product instances (including duplicates)
Sub collectAllInstances(Optional ByRef targetProd As Product = Nothing, Optional ByRef allInstances As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectAllInstances
    If targetProd Is Nothing Then Set targetProd = rootProd
    If allInstances Is Nothing Then Set allInstances = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add allInstances, "allInstances"   ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"       ' Always include targetProd for traversal
    Call traverseProduct(tmCollectAllInstances, traverseParams)
End Sub

' 2. Collect only part objects (excluding assemblies)
Sub collectParts(Optional ByRef targetProd As Product = Nothing, Optional ByRef parts As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectParts
    If targetProd Is Nothing Then Set targetProd = rootProd
    If parts Is Nothing Then Set parts = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add parts, "parts"                 ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCollectParts, traverseParams)
End Sub

' 3. Collect only product (assembly) objects (excluding parts)
Sub collectProducts(Optional ByRef targetProd As Product = Nothing, Optional ByRef products As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectProducts
    If targetProd Is Nothing Then Set targetProd = rootProd
    If products Is Nothing Then Set products = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add products, "products"           ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCollectProducts, traverseParams)
End Sub

' 4. Duplicate a product and its structure
Sub duplicateProduct(Optional ByRef srcProd As Product = Nothing, Optional ByRef duplicatedProd As Product = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmDuplicateProduct
    If srcProd Is Nothing Then Set srcProd = rootProd
    ' duplicatedProd is expected to be set by caller or remain Nothing
    Dim traverseParams As New Collection
    traverseParams.Add duplicatedProd, "duplicatedProd"   ' Required by traverseProduct
    traverseParams.Add srcProd, "srcProd"
    Call traverseProduct(tmDuplicateProduct, traverseParams)
End Sub

' 5. Assign property data to products during traversal
Sub assignProductData(Optional ByRef targetProd As Product = Nothing, Optional assignType As assignProductDataHelpers = -1, Optional value As Variant = Empty)
    ' Ensures traversalParams is constructed with correct keys for tmAssignProductData
    If targetProd Is Nothing Then Set targetProd = rootProd
    Dim traverseParams As New Collection
    traverseParams.Add assignType, "assignType"           ' Required by traverseProduct
    traverseParams.Add value, "value"
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmAssignProductData, traverseParams)
End Sub

' Helpers for assignProductData traversal mode:
' These specify which property to assign to the product during traversal.
Enum assignProductDataHelpers
    assignPN = 0                ' Assigns a Part Number to the product during assignProductData traversal
    assignName = 1              ' Assigns a Name to the product during assignProductData traversal
    assignDescription = 2       ' Assigns a Description to the product during assignProductData traversal
    assignReference = 3         ' Assigns a Reference value to the product during assignProductData traversal
    assignTemplate = 4          ' Assigns product data to all items in the product during assignProductData Traversal by copying each item from a template product.
    assignSource = 5            ' Assigns a Source (origin) to the product during assignProductData traversal
    assignNomenclature = 6      ' Assigns Nomenclature (standardized naming) to the product during assignProductData traversal
    assignRevision = 7          ' Assigns a Revision identifier to the product
    assignMaterial = 8          ' Assigns Material information to the product
    assignColor = 9             ' Assigns Color property to the product
    assignQuantity = 10         ' Assigns Quantity value to the product
    assignCustomProperty = 11   ' Assigns a custom property (user-defined) to the product
    assignMass = 12             ' Assigns Mass property to the product
    assignVolume = 13           ' Assigns Volume property to the product
    assignDensity = 14          ' Assigns Density property to the product
    assignManufacturer = 15     ' Assigns Manufacturer information to the product
    assignProject = 16          ' Assigns Project or job number to the product
End Enum

' Alternative approach: Use a mapping function for property assignment
' This allows for easier extension and avoids hardcoding logic in multiple places.
' Example usage:
'   Call assignProductProperty(prod, assignPN, "12345")
Public Sub assignProductProperty(prod As Product, assignType As assignProductDataHelpers, value As Variant)
    Select Case assignType
        Case assignPN
            prod.PartNumber = value
        Case assignName
            prod.Name = value
        Case assignDescription
            prod.Description = value
        Case assignReference
            prod.ReferenceProduct = value
        Case assignSource
            prod.Source = value
        Case assignNomenclature
            prod.Nomenclature = value
        Case assignRevision
            prod.Revision = value
        Case assignMaterial
            prod.Material = value
        Case assignMass
            prod.Mass = value
        Case assignVolume
            prod.Volume = value
        Case assignDensity
            prod.Density = value
        Case assignManufacturer
            prod.Manufacturer = value
        Case assignProject
            prod.Project = value
    End Select
End Sub

' 6. Similar to assignProductData, this is for batch assignments to bring products into allignment with a template.
Sub copyTemplate(Optional ByRef targetProd As Product = Nothing, Optional ByRef template As Product = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCopyTemplate
    If targetProd Is Nothing Then Set targetProd = rootProd
    If template Is Nothing Then Set template = templateProd
    Dim traverseParams As New Collection
    traverseParams.Add template, "template"               ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCopyTemplate, traverseParams)
End Sub

' 7. Collect only leaf products (end-nodes)
Sub collectLeaves(Optional ByRef targetProd As Product = Nothing, Optional ByRef leaves As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectLeaves
    If targetProd Is Nothing Then Set targetProd = rootProd
    If leaves Is Nothing Then Set leaves = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add leaves, "leaves"                   ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCollectLeaves, traverseParams)
End Sub

' 8. Collect only assemblies (products with children)
Sub collectAssemblies(Optional ByRef targetProd As Product = Nothing, Optional ByRef assemblies As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectAssemblies
    If targetProd Is Nothing Then Set targetProd = rootProd
    If assemblies Is Nothing Then Set assemblies = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add assemblies, "assemblies"           ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCollectAssemblies, traverseParams)
End Sub

' 9. Collect products matching a specific property value
Sub collectByProperty(Optional ByRef targetProd As Product = Nothing, Optional propName As String = "", Optional propValue As Variant = Empty, Optional ByRef matches As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectByProperty
    If targetProd Is Nothing Then Set targetProd = rootProd
    If matches Is Nothing Then Set matches = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add propName, "propName"               ' Required by traverseProduct
    traverseParams.Add propValue, "propValue"
    traverseParams.Add matches, "matches"
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCollectByProperty, traverseParams)
End Sub

' 10. Collect products with a specific name
Sub collectByName(Optional ByRef targetProd As Product = Nothing, Optional nameToMatch As String = "", Optional ByRef matches As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectByName
    If targetProd Is Nothing Then Set targetProd = rootProd
    If matches Is Nothing Then Set matches = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add nameToMatch, "nameToMatch"         ' Required by traverseProduct
    traverseParams.Add matches, "matches"
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCollectByName, traverseParams)
End Sub

' 11. Collect products with a specific part number
Sub collectByPartNumber(Optional ByRef targetProd As Product = Nothing, Optional partNumber As String = "", Optional ByRef matches As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectByPartNumber
    If targetProd Is Nothing Then Set targetProd = rootProd
    If matches Is Nothing Then Set matches = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add partNumber, "partNumber"           ' Required by traverseProduct
    traverseParams.Add matches, "matches"
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCollectByPartNumber, traverseParams)
End Sub

' 12. Collect products matching a custom filter function
Sub collectByCustomFilter(Optional ByRef targetProd As Product = Nothing, Optional filterFunc As String = "", Optional ByRef matches As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectByCustomFilter
    If targetProd Is Nothing Then Set targetProd = rootProd
    If matches Is Nothing Then Set matches = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add filterFunc, "filterFunc"           ' Required by traverseProduct
    traverseParams.Add matches, "matches"
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCollectByCustomFilter, traverseParams)
End Sub

' 13. Count the number of products (assemblies)
Sub countProducts(Optional ByRef targetProd As Product = Nothing, Optional ByRef count As Long = 0)
    ' Ensures traversalParams is constructed with correct keys for tmCountProducts
    If targetProd Is Nothing Then Set targetProd = rootProd
    Dim traverseParams As New Collection
    traverseParams.Add count, "count"                     ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCountProducts, traverseParams)
End Sub

' 14. Count the number of parts
Sub countParts(Optional ByRef targetProd As Product = Nothing, Optional ByRef count As Long = 0)
    ' Ensures traversalParams is constructed with correct keys for tmCountParts
    If targetProd Is Nothing Then Set targetProd = rootProd
    Dim traverseParams As New Collection
    traverseParams.Add count, "count"                     ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCountParts, traverseParams)
End Sub

' 15. Log traversal steps for debugging or reporting
Sub logTraversal(Optional ByRef targetProd As Product = Nothing, Optional logFilePath As String = "")
    ' Ensures traversalParams is constructed with correct keys for tmLogTraversal
    If targetProd Is Nothing Then Set targetProd = rootProd
    Dim traverseParams As New Collection
    traverseParams.Add logFilePath, "logFilePath"         ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmLogTraversal, traverseParams)
End Sub

' 16. Validate product structure for errors or inconsistencies
Sub validateStructure(Optional ByRef targetProd As Product = Nothing, Optional ByRef isValid As Boolean = True, Optional ByRef errorList As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmValidateStructure
    If targetProd Is Nothing Then Set targetProd = rootProd
    If errorList Is Nothing Then Set errorList = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add isValid, "isValid"                 ' Required by traverseProduct
    traverseParams.Add errorList, "errorList"
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmValidateStructure, traverseParams)
End Sub

' 17. Collect parent products for each node
Sub collectParents(Optional ByRef targetProd As Product = Nothing, Optional ByRef parents As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectParents
    If targetProd Is Nothing Then Set targetProd = rootProd
    If parents Is Nothing Then Set parents = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add parents, "parents"                 ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCollectParents, traverseParams)
End Sub

' 18. Collect child products for each node
Sub collectChildren(Optional ByRef targetProd As Product = Nothing, Optional ByRef children As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectChildren
    If targetProd Is Nothing Then Set targetProd = rootProd
    If children Is Nothing Then Set children = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add children, "children"               ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCollectChildren, traverseParams)
End Sub

' 19. Collect paths from root to each product/part
Sub collectPaths(Optional ByRef targetProd As Product = Nothing, Optional ByRef paths As Collection = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmCollectPaths
    If targetProd Is Nothing Then Set targetProd = rootProd
    If paths Is Nothing Then Set paths = New Collection
    Dim traverseParams As New Collection
    traverseParams.Add paths, "paths"                     ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmCollectPaths, traverseParams)
End Sub

' 20. Save all existing products/parts
Sub saveAll(Optional ByRef targetProd As Product = Nothing)
    ' Ensures traversalParams is constructed with correct keys for tmSaveAll
    If targetProd Is Nothing Then Set targetProd = rootProd
    Dim traverseParams As New Collection
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmSaveAll, traverseParams)
End Sub

' 21. Save all existing products/parts with a new name
Sub saveAsAll(Optional ByRef targetProd As Product = Nothing, Optional newName As String = "")
    ' Ensures traversalParams is constructed with correct keys for tmSaveAsAll
    If targetProd Is Nothing Then Set targetProd = rootProd
    Dim traverseParams As New Collection
    traverseParams.Add newName, "newName"                 ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmSaveAsAll, traverseParams)
End Sub

' 22. Send all products/parts to a specified destination
Sub sendTo(Optional ByRef targetProd As Product = Nothing, Optional destination As String = "")
    ' Ensures traversalParams is constructed with correct keys for tmSendTo
    If targetProd Is Nothing Then Set targetProd = rootProd
    Dim traverseParams As New Collection
    traverseParams.Add destination, "destination"         ' Required by traverseProduct
    traverseParams.Add targetProd, "targetProd"
    Call traverseProduct(tmSendTo, traverseParams)
End Sub

'Handle Input Functions
Function getActiveProduct(Optional ByRef rootDoc As Document = Nothing) As Product
    ' Get the currently active product in the CATIA session.
    ' Returns the Product object from the currently active CATIA document.
    ' If rootDoc is not provided, it defaults to CATIA.ActiveDocument.
    ' Usage: Set prod = getActiveProduct()
    If rootDoc Is Nothing Then Set rootDoc = CATIA.ActiveDocument
    Set getActiveProduct = rootDoc.Product
End Function

Function getTopProduct(Optional ByRef rootDoc As Document = Nothing) As Product
    ' Get the top-level (root) product in the assembly.
    ' Returns the Product object at the root of the current CATIA document.
    ' If rootDoc is not provided, it defaults to CATIA.ActiveDocument.
    ' Useful for operations that need to start at the assembly root.
    ' Usage: Set topProd = getTopProduct()
    If rootDoc Is Nothing Then Set rootDoc = CATIA.ActiveDocument
    Set getTopProduct = rootDoc.Product
End Function

Function getSelectedProduct(Optional ByRef rootSel As Selection = Nothing) As Product
    ' Get the product currently selected by the user.
    ' Returns the Product object corresponding to the first item in the current selection.
    ' If rootSel is not provided, it defaults to CATIA.ActiveDocument.Selection.
    ' If nothing is selected, returns Nothing.
    ' Usage: Set selProd = getSelectedProduct()
    If rootSel Is Nothing Then Set rootSel = CATIA.ActiveDocument.Selection
    If rootSel.Count > 0 Then
        Set getSelectedProduct = rootSel.Item(1).Value
    Else
        Set getSelectedProduct = Nothing
    End If
End Function

Function getTemplateProduct(templateName As String) As Product
    ' Get the product used as a template for operations.
    ' Searches all open CATIA documents for one with the specified templateName.
    ' Returns the Product object of the matching document, or Nothing if not found.
    ' Useful for copying properties or structure from a template product.
    ' Usage: Set templateProd = getTemplateProduct("TemplateProductName.CATProduct")
    Dim prod As Product
    Dim doc As Document
    For Each doc In CATIA.Documents
        If doc.Name = templateName Then
            Set prod = doc.Product
            Exit For
        End If
    Next
    Set getTemplateProduct = prod
End Function

Sub handleMultipleSelections(selectedProds As Collection)
    ' Handle scenarios where multiple products are selected.
    ' Accepts a Collection of Product objects (selectedProds).
    ' Iterates through each product and performs custom logic as needed.
    ' This is a placeholder for batch operations on multiple selections.
    ' Usage: Call handleMultipleSelections(selectedProds)
    Dim prod As Product
    For Each prod In selectedProds
        ' Implement custom logic for each selected product here.
    Next
End Sub

Function getUserInputString(prompt As String) As String
    ' Prompt user for a string input.
    ' Displays an InputBox with the provided prompt and returns the entered string.
    ' Usage: userInput = getUserInputString("Enter the part name:")
    getUserInputString = InputBox(prompt, "Input Required")
End Function

Function getUserInputNumber(prompt As String) As Double
    ' Prompt user for a numeric input.
    ' Displays an InputBox with the provided prompt and returns the entered value as Double.
    ' If the input is not numeric, returns 0.
    ' Usage: numValue = getUserInputNumber("Enter the quantity:")
    Dim strInput As String
    strInput = InputBox(prompt, "Input Required")
    If IsNumeric(strInput) Then
        getUserInputNumber = CDbl(strInput)
    Else
        getUserInputNumber = 0
    End If
End Function

Function getUserInputBoolean(prompt As String) As Boolean
    ' Prompt user for a Yes/No or True/False input.
    ' Displays a message box with Yes/No buttons and returns True if Yes is selected, False otherwise.
    ' Usage: isConfirmed = getUserInputBoolean("Do you want to proceed?")
    Dim response As VbMsgBoxResult
    response = MsgBox(prompt, vbYesNo + vbQuestion, "Please Confirm")
    getUserInputBoolean = (response = vbYes)
End Function

Function getUserInputFilePath(prompt As String) As String
    ' Prompt user to select a file path.
    ' Opens a file picker dialog with the provided prompt as the title.
    ' Returns the selected file path as a string, or an empty string if cancelled.
    ' Requires reference to Microsoft Office library for FileDialog.
    ' Usage: filePath = getUserInputFilePath("Select a file to import:")
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    fd.Title = prompt
    If fd.Show = -1 Then
        getUserInputFilePath = fd.SelectedItems(1)
    Else
        getUserInputFilePath = ""
    End If
End Function

Function getUserInputFolderPath(prompt As String) As String
    ' Prompt user to select a folder path.
    ' Opens a folder picker dialog with the provided prompt as the title.
    ' Returns the selected folder path as a string, or an empty string if cancelled.
    ' Requires reference to Microsoft Office library for FileDialog.
    ' Usage: folderPath = getUserInputFolderPath("Select a destination folder:")
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFolderPicker)
    fd.Title = prompt
    If fd.Show = -1 Then
        getUserInputFolderPath = fd.SelectedItems(1)
    Else
        getUserInputFolderPath = ""
    End If
End Function

Function getUserInputFromList(prompt As String, options As Variant) As Variant
    ' Prompt user to select from a list of options.
    ' Displays an InputBox with a numbered list of options.
    ' Returns the selected option as a Variant, or an empty string if invalid selection.
    ' The options parameter should be a 0-based array or Variant array.
    ' Usage: selectedOption = getUserInputFromList("Choose a material:", Array("Steel", "Aluminum", "Plastic"))
    Dim i As Integer, msg As String
    msg = prompt & vbCrLf
    For i = LBound(options) To UBound(options)
        msg = msg & (i + 1) & ". " & options(i) & vbCrLf
    Next
    Dim sel As String
    sel = InputBox(msg, "Select Option")
    If IsNumeric(sel) And sel >= 1 And sel <= UBound(options) - LBound(options) + 1 Then
        getUserInputFromList = options(CInt(sel) - 1)
    Else
        getUserInputFromList = ""
    End If
End Function

Function getUserInputMultiSelect(prompt As String, options As Variant) As Collection
    ' Prompt user to select multiple items from a list.
    ' Displays an InputBox with a numbered list of options and instructions to enter numbers separated by commas.
    ' Returns a Collection of selected options.
    ' The options parameter should be a 0-based array or Variant array.
    ' Usage: Set selectedItems = getUserInputMultiSelect("Select components:", Array("Bolt", "Nut", "Washer"))
    Dim i As Integer, msg As String
    Set getUserInputMultiSelect = New Collection
    msg = prompt & vbCrLf
    For i = LBound(options) To UBound(options)
        msg = msg & (i + 1) & ". " & options(i) & vbCrLf
    Next
    msg = msg & vbCrLf & "Enter numbers separated by commas (e.g., 1,3,4):"
    Dim sel As String, arr, idx
    sel = InputBox(msg, "Select Multiple Options")
    arr = Split(sel, ",")
    For Each idx In arr
        If IsNumeric(idx) Then
            i = CInt(idx) - 1
            If i >= LBound(options) And i <= UBound(options) Then
                getUserInputMultiSelect.Add options(i)
            End If
        End If
    Next
End Function



ByRef tdProduct As Product, ByRef tdParams As Collection, Optional ByRef templateProduct As Product = Nothing)
    ' Implementation for generating a tool design (TD)
    ' accepts the following arguments:
        'Required: tdProduct as product
        'Required: tdParams as collection
            ' createNewProduct as boolean
            ' templateProduct as product
            ' protectRefs as boolean
            ' addSuffixToSel as boolean
            ' seqOrSingle as boolean
        'Optional: templateProduct as product

'
' Logic Flow for generateTD:
'   1. Validate required arguments:
'       - Ensure tdProduct (Product) and tdParams (Collection) are provided.
'   2. Parse tdParams collection for expected keys/values:
'       - createNewProduct (Boolean): Whether to create a new product or use existing.
'       - templateProduct (Product): Template to use for property/structure copying.
'       - protectRefs (Boolean): Whether to protect reference links during duplication.
'       - addSuffixToSel (Boolean): Whether to add a suffix to selected items.
'       - seqOrSingle (Boolean): Whether to process sequentially or as a single operation.
'   3. If createNewProduct is True:
'       - Create a new product, optionally based on templateProduct.
'       - Copy relevant properties and structure from templateProduct if provided.
'   4. If protectRefs is True:
'       - Ensure reference links are preserved or protected during duplication.
'   5. If addSuffixToSel is True:
'       - Add a suffix to the names or part numbers of selected items as needed.
'   6. If seqOrSingle is True:
'       - Process items in sequence; otherwise, process as a single batch.
'   7. Perform main tool design generation logic:
'       - Duplicate or modify product structure as required.
'       - Assign properties, update references, and apply template as needed.
'   8. Finalize and return or update the generated tool design product.
'   9. Handle any errors or logging as appropriate.


End Sub